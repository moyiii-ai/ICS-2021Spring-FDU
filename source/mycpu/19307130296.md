# 五级流水线 MIPS CPU 实验报告

计算机科学与技术

19307130296

孙若诗

## 一、实现指令

### 1. R型指令

R-type = op(6) + rs(5) + rt(5) + rd(5) + shamt(5) + funct(6)

* addu : GPR[rd] = GPR[rs] + GPR[rt]
* subu : GPR[rd] = GPR[rs] - GPR[rt]
* and : GPR[rd] = GPR[rs] & GPR[rt]
* or : GPR[rd] = GPR[rs] | GPR[rt]
* nor : GPR[rd] = ~(GPR[rs] | GPR[rt])
* xor : GPR[rd] = GPR[rs] ^ GPR[rt]
* sll : GPR[rd] = GPR[rt] << shamt
* sra : GPR[rd] = GPR[rt] >>> shamt (arithmetic)
* srl : GPR[rd] = GPR[rt] >> shamt (logical)
* slt : GPR[rd] = (GPR[rs] < GPR[rt]) (signed)
* sltu : GPR[rd] = (GPR[rs] < GPR[rt]) (unsigned)
* jr : pc = GPR[rs]

### 2. I型指令

I-type = op(6) + rs(5) + rt(5) + imm(16)

* addiu : GPR[rt] = GPR[rs] + sign_extend(imm)
* andi : GPR[rt] = GPR[rs] & zero_extend(imm)
* ori : GPR[rt] = GPR[rs] | zero_extend(imm)
* xori : GPR[rt] = GPR[rs] ^ zero_extend(imm)
* slti : GPR[rt] = (GPR[rs] < imm) (signed)
* sltiu : GPR[rt] = (GPR[rs] < imm) (unsigned)
* lui : GPR[rt] = imm << 16
* beq : if(GPR[rs] == GPR[rt])  pc += imm << 2
* bne : if(GPR[rs] != GPR[rt])
pc += imm << 2
* lw : GPR[rt] = mem[GPR[rs] + sign_extend(offset)]
* sw : mem[GPR[rs] + sign_extend(offset)] = GPR[rt]

### 3. J型指令

J-type = op(6) + instr_index(26)

* j : pc = pc + (instr_index << 2)
* jal : GPR[31] = pc + 8, pc = pc + (instr_index << 2)

## 二、阶段分析

### 1. Fetch

### 2. Decode

这一阶段的主要任务是：指令解码，生成控制信号、从 Regfile（寄存器文件堆）中读取数据、判断是否跳转。

### 3. Execute

这一阶段的主要任务是完成计算，围绕ALU展开。

输入接口为6位的control[5:0]（alu_shamt、alu_imm、alu_funct），5位的rd、shamt和32位的imm、vs、vt。输出接口为5位的rdE和32位的out、vtE。

Execute模块首先根据alu_shamt、alu_imm处理出ALU的两个参数，然后例化ALU进行运算。ALU的输入为4位的alu_funct和32位的两个运算参数，输出为32位的结果out。

rd和vt的值不发生改变，仅传向下一个阶段。

### 4. Memory

### 5. Write Back

## 三、其他

1. signed' 和 $signed() 有什么区别？

2. 直接把输入接到输出里？assign之后再接给下层模块？


